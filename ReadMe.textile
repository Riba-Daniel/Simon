
h1. (simple) Simon BDD framework

Simon is a BDD framework for testing apps on iOS simulators and devices. I've written it to be as simple to use and easy to add to your projects as possible. In fact, it's so simple that all you need to do is to write a story file, include a single line macro to run Simon, and then include another single line macro on each step implementation. 

h2. Why use a BDD framework?

Customes don't understand code. So showing then a Unit test run or raw code means little to them. That's ok, that's why we write the code and they don't. However, customers do understand their own requirements and they usually can express those requirements quite well. 

Behaviour Driven Development is an agile technique where we get the customer to express their requirements in simple story like terns. Then using a framework like Simon, we match executable code to the stories, thus proving that they are implemented. By doing this we can prove that the app meets the customers expectations.

h2. Why did I write Simon?

There are other BDD style frameworks for iOS. But after looking at them, they each had something I wasn't that fond of. So I sat down and thought about what I wanted as a developer. I came up with this list:

* I wanted to use Objective C because that's what every iOS developer already knows.
* I wanted it to be easy to include and run without requiring modifications to the system.
* I wanted to use as little as possible "Glue" code to relate story steps to Objective C methods.
* I wanted the stories to be stored in seperate files from the code so they would be easier to modify and update and the customer could read them.
* I wanted it to run on the simulator.
* I wanted to be easily able to locate and tap controls on a UI.
* I wanted it - most of all - to be dead simple to run. 

h2. Where did the name come from?

When I was thinking about keeping things simple, I thought of the old nursery rhyme "Simple Simon":http://en.wikipedia.org/wiki/Simple_Simon_(nursery_rhyme) and the name stuck.

h2. Ok how does it really work?

Here's the basic sequence:

# The Customer and Developer work together to write stories in the form "As/Given .... then ...." For example "Given Simon is running Then I expect it to execute the stories".
# You create a new target which runs your app as though you where going to manually test it.
# You add the text files containing the stories to your code base and the new target.
# You add the Simon framework to this target.
# You then open the startup code and add 1 line to get Simon launched in the background.
# You write one or more classes containing the code that executed each step in the stories.
# You add one line macros to the classes for each step, mapping the story step to a method.
# You lanuch the target on your simulator or device. Simon will automatically startup, read the story files, match the steps to the methods and run each story. At the end Simon will produce a report detailing successful executions of stories or failures.

h1. How do I install it?

First there are two other frameworks you need to download. They are:

* "dUsefulStuff framework":http://github.com/drekka/dUsefulStuff - version 0.0.13+ (Provides some common code I use)
* "dNodi framework":http://github.com/drekka/dNodi - version 0.3.0+ (Provides XPath like searching)

Download the DMG files for each. Open each one and drag and drop the framework files to a directory. Open XCode again, select your target and go to *Build Phases* and *Link Binary With Libraries*. Then click *&#91;+&#93;* to add library. Select *Add Other...* and then the framework directory you just copied. Do the same for the other frameworks.

h1. Adding Simon to your project

Simon is designed to run on a background thread in your app. To save you from having the headache of working this out, there is a simple macro you can use to install and run stories. This macros:

# Sets up Simon on a background thread.
# Waits for your app to finish loading by watching the UIApplication notifications. 
# Once your app is up, starts running the stories.
# When all stories have been run, displays a report of the results.

You place this macro into the *main.m* file of your app. Here's a simplified example so show you what it looks like:

<pre lang="objc">
#import <UIKit/UIKit.h>

#import "SISimon.h"

int main(int argc, char *argv[]) {
   
   NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];

   // Add Simon.
   SIRun();

   int retVal = UIApplicationMain(argc, argv, nil, @"YourAppDelegate");
   
   [pool release];
   return retVal;
}
</pre>

There are two versions of the macros

* *SIRun()* which searches the app for story files (*.stories) and runs them all.
* *SIRunFile(story-filename)* which runs stories from the specified file only. The story-filename does not have to have the .stories extension. So 'My' and 'My.stories' give the same result.

h2. How to I write a story?

Stories are written in plan text files with a ".stories" extension Here's an example:

_example.stories_
<pre lang="objc">
Story: Example story showing the basic syntax.
Given Simon is working
Then I should be able to see abc and 5 in the log
and say goodby at the end.
</pre>

Thats pretty simple. The *Story: ...* line gives the story a name. The rest of the lines outline the story and what is expected. Simon does impose some rules about the first word on each line. Ultimately it doesn't matter, but by imposing some simple rules, it helps to better understand the stories. Yes you can have more than one per file. Here's an outline of the syntax rules:

* Each story must start with a line that begins with the word *story* or *story:*.
* The structure of the story lines must conform to:
** *As ...* _(optional)_
** *Given ...*
** *And ...* _(zero or more)_
** *Then ...* _(zero or more)_
** *And ...* _(zero or more)_
* Leading and trailing blanks are ignored on each line.
* Lines that begin with *#* are treated as comments and ignored.
* Blank lines are ignored.

h2. How do I relate a story to the executable code?

Firstly Simon regards each line in a story as a seperate item to be executed. So lets look at the @Given Simon is working@ line from the above story. Lets say we have a class called StepImplementations.m and we want to map the step to a method in it. Here's what it would look like:

<pre lang="objc">
#import <SISimon/SISimon.h>

@interface StepImplementation : NSObject {
}
@end

@implmentation StepImplementation

   SIMapStepToSelector(@"Given Simon is working", simonIsRunning) 
   -(void) simonIsRunning {
      NSLog(@"Woo hoo, Simon is running");
   }

@end
</pre>

The first thing you wil notice is the inclusion of the SISimon.h header file. A necessary evil unfortunately. The second thing you will notice is the 
<pre>SIMapStepToSelector(@"Given Simon is working", simonIsRunning)</pre>
line. That's Simon. This preprocessor macro instructs Simon to map the given step to the selector. 

Now it's not obvious from the above, but that first parameter is a "regular expression":http://developer.apple.com/library/ios/#documentation/Foundation/Reference/NSRegularExpression_Class as specified in the doc for the "NSRegularExpression class":http://developer.apple.com/library/ios/#documentation/Foundation/Reference/NSRegularExpression_Class in Apple's documentation. This means that we can use it to pick up a wide variety of steps and also (using regular expression groups) pick out arguments to pass to the selector. Oh, and the second argument is the selector to execute. You don't need to use objective C's @selector(...)@ with this as Simon needs it as text. Plus it's less to type in :-)

h2. How do I map arguments in a step?

Lets look at the *Then ...* step

<pre>Then I should be able to see abc and 5 in the log</pre>

As you can see there are two possible arguments in this step - *abc* and *5*. Simon can map these quite simply. The only rule is that the order of arguments in the method that will be executed matches the order of arguments in the step. Of course Simon also expects that the data types are a match as well. Here's the mapping:

<pre lang="objc">
SIMapStepToSelector(@".* I should be able to see (.*) and (.*) in the log", verifyText:andNumber:)

-(void) verifyText:(NSString *) text andNumber:(int) number {
   NSLog(@"Text: %@", text);
   NSLog(@"Number: %i", number);
}
</pre>

Simon will automatically scan the data types of the arguments and attempt a matching conversion. Also notice that in the regular expression I set the start to match any characters. This means that, for example, I could use this same expression with both a *Then ...* and a *And ...* step.

Note that each step in a story can matched to only one selector. But that a selector can be mapped to any number of story steps. This gives you the ability to share code across many steps, saving you from repeating yourself. Also know as the "DRY principle":http://en.wikipedia.org/wiki/Don't_repeat_yourself.

h2. Hey, Simon executed the wrong step mapping!

Probably not. You have to watch those step mapping regexs. When mapping story steps to mappings, Simon accepts the first match it finds and stops looking, assuming that for any given story step, there will only be a single mapping. So if you have used a regex on a different mapping that also matches that step, and that mapping is queried first when looking for mappings, then Simon will use it instead. Lets look at an example. Assume you have the step @then do something interesting@ and that you have the following step mappings:

<pre lang="objc">
SIMapStepToSelector(@"then do something", doSomething)
-(void) doSomething {...}

SIMapStepToSelector(@"then do something interesting", doSomethingInteresting)
-(void) doSomethingInteresting {...}
</pre>
 
Simon is most likely to check the @doSomething@ mapping before it checks the @doSomethingInteresting@ mapping and because the regex "then do something" will match, Simon will probably use this method for the mapping even though there is a more explicit mapping. 

There are a number of ways to deal with this, si for the moment I've left it pretty open. I would suggest that a likely best solution is to consider using the regex  start of line '^' or end of line '$' expressions to better define. To go with our example, the following change would fix the problem:

<pre lang="objc">
SIMapStepToSelector(@"then do something$", doSomething)
-(void) doSomething {...}
</pre>

Because specifying that the expression must occur at the end of the line means it will no longer match the longer story step text.

h1. But wait! what if the step implementations are in different classes?

This is where Simon gets a bit smarter than the original Simon. 

h2. First, when steps are in the same class

Simon instantiates each class that contains mapped steps when it needs to run those steps. In addition it also caches and reuses these objects, so transferring data between story step mappings in the same class is as simple as using class properties. 

h2. And when they are in different classes

When dealing with step mappings in different classes, Simon has to be a little smarter. Each story has a local storage area Simon can use to transfer objects between classes without these classes even being aware of each other. Accessing this storage is done through two macros. Here is an example:

_Communications.stories_
<pre lang="objc">
Story: Should be able to pass objects between step classes.
Given this class stores abc in the story storage using key def
then this class should be able to retrieve abc from storage with key def
</pre>

_CommsASteps.m_

<pre lang="objc">
@implementation CommsASteps

   SIMapStepToSelector(@"Given this class stores (.*) in the story storage using key (.*)", storesString:withKey:)

   -(void) storesString:(NSString *) aString withKey:(NSString *) key{
      SIStoreInStory(key, aString);
   }
 
@end
</pre>

CommsAStep reads a key and a value from a step and then stores the value in the story cache so that other objects can access it.

_CommsBSteps.m_

<pre lang="objc">
@implementation CommsBSteps

   SIMapStepToSelector(@"then this class should be able to retrieve (.*) from storage with key (.*)", retrieveString:withKey:)

   -(void) retrieveString:(NSString *) aString withKey:(NSString *) key{
      NSString *value = SIRetrieveFromStory(key);
      GHAssertEqualStrings(value, aString, @"Strings do not match");
   }

@end
</pre>

CommsBSteps then reads that value back from the cache and verifies it.

h2. Just in case you are wondering

After each story has finished, Simon clears out the story's caches - releasing the step mapping implementations. So you cannot transfer data between stories. That may come later.

h1. How do I interact with my app?

In addition to the simple steps above for creating stories, Simon also includes a framework for accessing the components that make up a UI in an app. Simon does this by mapping out the tree structure of a UI and allowing you to use "dNodi's":https://github.com/drekka/dNodi xpath like queries to drill down through the interface, locate the controls you want, and perform various actions upon them. Tapping for example. Simon implements the dNodi DNNode protocol via a category on UIView. This keeps you from having to work through the mapping of dNodie expressions to the UI object graph.

	A lot of this code is wrapped by preprocessor macros which can be found in the *SISimon.h* file. 


h2. Viewing the UI tree

A good way to understand this is to include this code in a step. It will print out the current tree structure showing each UIView's class and index number in the hirachy. Some classes are further suplimented with attributes which Simon has identified as searchable ones.

<pre lang="objc">
SIMapStepToSelector(@"then print the UI tree", printTheUITree)
-(void) printTheUITree {
	SIPrintCurrentWindowTree();
}
</pre>

h2. Getting a reference to a control on the UI

There are some other useful preprocessor macros. One which provides a reference to a single control using a dNodi path to locate it, and the other returning a list of zero or more controls from a path. They look like this:

<pre lang="objc">
SIMapStepToSelector(@"then get the button", getTheButton)
-(void) getTheButton {
	NSError *error = nil;
	UIButton *aButton = (UIButton *) SIFindView(@"/UIView/UIRoundedRectButton", &error);
	if (aButton == nil) {
		// Error!
	}
}
</pre>

<pre lang="objc">
SIMapStepToSelector(@"then get all the controls", getAllControls)
-(void) getAllControls {
	NSError *error = nil;
	NSArray *controls = SIFindViews(@"/UIView", &error);
	if (controls == nil) {
		// Error!
	}
}
</pre>

h2. Tapping a control

This in an initial cut of this and I expect to expand it as I gain understanding of the best wasy to maniplulate a UI. 

Tapping a control such as a button can also be accessed through a preprocessor macro which takes a path to the control as a parameter. Here is some example code:

<pre lang="objc">
SIMapStepToSelector(@"then tap the button", tapButton)
-(void) tapButton {
	NSError *error = nil;
	SITapControl(@"/UIView/UIRoundedRectButton", &error);
	if (error != nil) {
		// Error!
	}
}
</pre>

h2. Accessing view properties using KVC

When Simon encounters a request to select based on the attribute of a UIView, it passes the attribute value to iOS's KVC API. This means that any property of a UIView which is KVC complient can be used in a query. For example, on a UIButton @[labelText.text='hello']@ works just fine to find a button which has the text "hello" on it. Funny enough, @frame.size@ does not work. Apparently @CGRect@ is not understood by KVC although various other primitive types are.

.h1 Simon's Assertion macros

These macros can be used in your step mappings to assert values and trigger errors which Simon will report on. 

|_. Macros |_. Description |
| SIThrowException(name, message, ...) | Throws an exception using the given name, message and arguments. Mostly used by the assertion macros. |
| SIFail() | Indicates that the test should fail immediately. |
| SIAssertTrue(expr) | Fails if the expression results in NO. |
| SIAssertFalse(expr) | Fails if the expression results in YES. |
| SIAssertNil(expr) | Fails if the expression results in something other than nil. |
| SIAssertNotNil(expr) | Fails if the expression results in a nil. |
| SIAssertEquals(x, y) | Fails if the x and y are not equals. Uses x == y to do the comparison. |
| SIAssertObjectEquals(objX, objY) | Fails if the two objects are not equal. Uses [objX isEqual:objY] to do the comparison. |

In addition to the above macros there are also *SIFail(message, ...), SIAssertTrue(expr, message, ...), SIAssertFalse(expr, message, ...), SIAssertNil(expr, message, ...), SIAssertNotNil(expr, message, ...), SIAssertEquals(x, y, message, ...),* and *SIAssertObjectEquals(objX, objY, message, ...)* which provide exactly the same functionality except that you also provide a custom message text and arguments. These are formatted according to the rules for the NSString:stringWithFormat: method. 

h1. I'd like to say thanks to several developers for developing the following tools:

* Toma≈æ Kragelj for "Appledoc V2":http://www.gentlebytes.com/home/appledocapp
* Gabriel Handford for "GHUnit":https://github.com/gabriel/gh-unit
* Erik Doernenburg for "OCMock":http://www.mulle-kybernetik.com/software/OCMock
